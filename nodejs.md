# NodeJS

## Верхнеуровневое устройство
 
Вводный материал <https://www.youtube.com/watch?v=243pQXC5Ebs&list=WL&index=41>
 
Содержит два основных компонента:
- [V8](https://medium.com/nuances-of-programming/движок-javascript-что-внутри-f0db9b988b90)
- [LibUV](https://imnotgenius.com/21-sobytijnyj-tsikl-biblioteka-libuv/?ysclid=lgxbin3g40962538536)

### V8
- Транслирует JS код в машинный код
- Выделяет память для объектов
- Занимается сборкой мусора

### LibUV
- Кроссплатформенный I/O
- - Файловая система
- - Сеть
- - Общий программный интерфейс для взаимодейтсвия с ОС
- Event loop

**V8** говорить nodejs, чтобы он что-то сделал в ОС, с файлом, с сетью, а nodejs передает запрос в libUV.
И тем самым достигается кросс платформеность, так как libUV знает как работать на windows, linux, macos.

Под капотом использует 4 потока. 
Ну или как говорит ChatGPT: "количество потоков в пуле рабочих потоков libuv определяется при запуске и по умолчанию равно количеству ядер процессора."

### Event loop

Плюсы:
- Дает большое удобноство, так как нам не нужно управлять потоками.
- Дает большую скорость работы над простыми операциями ввода/вывода.

Минусы:
- Много асинхронного кода.
- Любое сложное вычисление, занимает поток и приложение блокируется.

### Многопоточный ввод/вывод

У LibUV есть ограничение на кол-во используемых потоков, она может использовать только 4 потока.

Ну или как говорит ChatGPT: "количество потоков в пуле рабочих потоков libuv определяется при запуске и по умолчанию равно количеству ядер процессора."

Показать пример необлокирующего ввода вывода, можо через встроенную библиотеку `crypto`, запуская 5 вызово в цикле
и смотреть на сколько быстро вызываются колбэки. 
Пятый колбэк всегда будет выполняться позже первых четырех, так как на него нехватает потоков в LibUV.

### Worker threads

С версии 11.7.0 была бобавлена возможность запускать код в отдельном потоке в рамках одного и того же процесса.

Удобно применять, если нужно выполнить какую нибудь ресурсоёмкую операцию например на картинкой, или большим xml файлом, и не 
заблокировать основной поток.

ДОПИСАТЬ СРАВНЕНИЕ С node cluster и spawn node process....

### Не блокирующий ввод/вывод

Неблокирующий ввод выод основан на шаблоне "Reactor" - это архитектурный шаблон проектирования, используемый для асинхронной обработки сервисных запросов, которые поступают от различных клиентов к одному или нескольким обслуживающим модулям. Это особенно полезно в ситуациях, где у вас есть множество открытых соединений, которые в основном ожидают и должны быстро реагировать на события, когда они происходят.

Шаблон "Reactor" обычно состоит из следующих компонентов:

- Reactor: Этот компонент управляет регистрацией и удалением обработчиков и их событий, и он также диспетчеризует события обработчикам. Это, по сути, ядро шаблона Reactor.
- Обработчики (Handlers): Обработчики - это объекты, которые реагируют на определенные типы событий. Каждый обработчик имеет определенную реализацию, которая определяет, как он будет реагировать на свое событие.
- События (Events): События - это определенные условия, которые обработчики могут обрабатывать. Когда событие происходит, Reactor диспетчеризует его соответствующему обработчику.
- Демультиплексор событий (Event Demultiplexer): Это компонент, который блокирует ожидание наступления любого из зарегистрированных событий. Как только одно из этих событий происходит, демультиплексор событий уведомляет Reactor, который затем диспетчеризует событие соответствующему обработчику.

Библиотека libuv, которая используется в Node.js, и технология Twisted в Python - это примеры реализаций шаблона Reactor. Они используют шаблон Reactor для предоставления эффективного механизма асинхронного ввода-вывода.

Демультиплексор событий - это компонент операционной системы или библиотеки ввода-вывода, который отслеживает множество источников ввода-вывода и уведомляет приложение, когда один или более из этих источников готовы для чтения или записи.

Он эффективен, потому что позволяет приложению ожидать данные от множества источников ввода-вывода без необходимости постоянно опрашивать каждый источник на предмет наличия данных. Вместо этого демультиплексор событий оповещает приложение, когда данные доступны, что позволяет приложению использовать свои ресурсы более эффективно.

Различные операционные системы предоставляют разные механизмы для демультиплексации событий. Например, в Unix-подобных системах часто используются механизмы select, poll и epoll, а в Windows - I/O Completion Ports.

